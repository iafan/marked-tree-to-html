{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type { TokenizerExtension, RendererExtension } from 'marked'\nimport { renderTree } from 'tree-to-html'\n\n/**\n * Check if a code block contains ASCII tree characters.\n */\nexport function isTreeStructure(code: string): boolean {\n  const hasBranch = code.includes('├')\n  const hasCorner = code.includes('└')\n  const hasDash = code.includes('─')\n  return (hasBranch || hasCorner) && hasDash\n}\n\n/**\n * Post-process rendered HTML to convert tree containers to actual tree HTML.\n * Call this after marked.parse() completes and DOM is ready.\n */\nexport function renderTreeBlocks(): void {\n  const containers = document.querySelectorAll<HTMLElement>('.tree-container-raw')\n\n  for (const container of containers) {\n    const source = container.textContent || ''\n    if (!source.trim()) continue\n\n    try {\n      const html = renderTree(source)\n      container.outerHTML = html\n    } catch (error) {\n      console.error('Failed to render tree:', error)\n    }\n  }\n}\n\n/**\n * Marked extension that intercepts code blocks with tree structure.\n * Use with: marked.use({ extensions: [treeExtension] })\n */\nexport const treeExtension: TokenizerExtension & RendererExtension = {\n  name: 'tree',\n  level: 'block',\n  start(src: string) {\n    // Look for code blocks that might contain tree structure\n    const match = src.match(/^```(?:tree)?\\n/)\n    return match?.index\n  },\n  tokenizer(src: string) {\n    // Match code blocks: ```tree or ``` followed by tree content\n    const treeMatch = src.match(/^```tree\\n([\\s\\S]*?)\\n```/)\n    if (treeMatch) {\n      return {\n        type: 'tree',\n        raw: treeMatch[0],\n        text: treeMatch[1],\n      }\n    }\n\n    // Match unmarked code blocks that contain tree characters\n    const codeMatch = src.match(/^```\\n([\\s\\S]*?)\\n```/)\n    if (codeMatch && isTreeStructure(codeMatch[1])) {\n      return {\n        type: 'tree',\n        raw: codeMatch[0],\n        text: codeMatch[1],\n      }\n    }\n\n    return undefined\n  },\n  renderer(token) {\n    const escaped = token.text\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n    return `<div class=\"tree-container-raw\">${escaped}</div>\\n`\n  },\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,0BAA2B;AAKpB,SAAS,gBAAgB,MAAuB;AACrD,QAAM,YAAY,KAAK,SAAS,QAAG;AACnC,QAAM,YAAY,KAAK,SAAS,QAAG;AACnC,QAAM,UAAU,KAAK,SAAS,QAAG;AACjC,UAAQ,aAAa,cAAc;AACrC;AAMO,SAAS,mBAAyB;AACvC,QAAM,aAAa,SAAS,iBAA8B,qBAAqB;AAE/E,aAAW,aAAa,YAAY;AAClC,UAAM,SAAS,UAAU,eAAe;AACxC,QAAI,CAAC,OAAO,KAAK,EAAG;AAEpB,QAAI;AACF,YAAM,WAAO,gCAAW,MAAM;AAC9B,gBAAU,YAAY;AAAA,IACxB,SAAS,OAAO;AACd,cAAQ,MAAM,0BAA0B,KAAK;AAAA,IAC/C;AAAA,EACF;AACF;AAMO,IAAM,gBAAwD;AAAA,EACnE,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM,KAAa;AAEjB,UAAM,QAAQ,IAAI,MAAM,iBAAiB;AACzC,WAAO,OAAO;AAAA,EAChB;AAAA,EACA,UAAU,KAAa;AAErB,UAAM,YAAY,IAAI,MAAM,2BAA2B;AACvD,QAAI,WAAW;AACb,aAAO;AAAA,QACL,MAAM;AAAA,QACN,KAAK,UAAU,CAAC;AAAA,QAChB,MAAM,UAAU,CAAC;AAAA,MACnB;AAAA,IACF;AAGA,UAAM,YAAY,IAAI,MAAM,uBAAuB;AACnD,QAAI,aAAa,gBAAgB,UAAU,CAAC,CAAC,GAAG;AAC9C,aAAO;AAAA,QACL,MAAM;AAAA,QACN,KAAK,UAAU,CAAC;AAAA,QAChB,MAAM,UAAU,CAAC;AAAA,MACnB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA,EACA,SAAS,OAAO;AACd,UAAM,UAAU,MAAM,KACnB,QAAQ,MAAM,OAAO,EACrB,QAAQ,MAAM,MAAM,EACpB,QAAQ,MAAM,MAAM;AACvB,WAAO,mCAAmC,OAAO;AAAA;AAAA,EACnD;AACF;","names":[]}